---
alwaysApply: false
---

# Testing Rules for React/Next.js Applications

## Testing Framework Setup
- Use Jest as the primary testing framework for unit and integration tests
- Use React Testing Library (RTL) for component testing
- Use @testing-library/jest-dom for custom matchers
- Use @testing-library/user-event for user interaction testing
- Use MSW (Mock Service Worker) for API mocking
- Use @testing-library/react-hooks for testing custom hooks
- Use Playwright for end-to-end (E2E) testing

## Test File Organization
- Place test files alongside source files with `.test.tsx` or `.spec.tsx` extension
- Use `__tests__` directories for complex test suites
- Group related tests using `describe` blocks
- Use descriptive test names that explain the expected behavior
- Follow the pattern: "should [expected behavior] when [condition]"

## Component Testing Best Practices
- Test component behavior, not implementation details
- Focus on user interactions and outcomes
- Use semantic queries (getByRole, getByLabelText) over getByTestId
- Test accessibility features and keyboard navigation
- Mock external dependencies and API calls
- Test component variants and edge cases
- Use data-testid sparingly and only for elements that can't be queried semantically

## Test Structure
```typescript
import { render, screen, fireEvent } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import '@testing-library/jest-dom'

describe('ComponentName', () => {
  const defaultProps = {
    // Define default props here
  }

  it('should render correctly with default props', () => {
    render(<ComponentName {...defaultProps} />)
    expect(screen.getByRole('button')).toBeInTheDocument()
  })

  it('should handle user interactions correctly', async () => {
    const user = userEvent.setup()
    render(<ComponentName {...defaultProps} />)
    
    const button = screen.getByRole('button')
    await user.click(button)
    
    expect(screen.getByText('Expected text')).toBeInTheDocument()
  })
})
```

## Custom Hook Testing
- Use @testing-library/react-hooks for testing custom hooks
- Test hook behavior in isolation
- Mock external dependencies
- Test error states and edge cases

```typescript
import { renderHook, waitFor } from '@testing-library/react'
import { useCustomHook } from './useCustomHook'

describe('useCustomHook', () => {
  it('should return initial state', () => {
    const { result } = renderHook(() => useCustomHook())
    expect(result.current.data).toBeNull()
    expect(result.current.loading).toBe(true)
  })

  it('should handle async operations', async () => {
    const { result } = renderHook(() => useCustomHook())
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false)
    })
    
    expect(result.current.data).toBeDefined()
  })
})
```

## API Mocking
- Use MSW for API mocking in tests
- Mock API responses for different scenarios
- Test loading states, success states, and error states
- Verify API calls are made with correct parameters

```typescript
import { rest } from 'msw'
import { setupServer } from 'msw/node'

const server = setupServer(
  rest.get('/api/data', (req, res, ctx) => {
    return res(ctx.json({ data: 'test data' }))
  }),
  rest.post('/api/submit', (req, res, ctx) => {
    return res(ctx.json({ success: true }))
  })
)

beforeAll(() => server.listen())
afterEach(() => server.resetHandlers())
afterAll(() => server.close())
```

## Test Utilities and Helpers
- Create custom render functions for components with providers
- Use test-utils for common testing patterns
- Create mock data factories for consistent test data
- Use beforeEach for common setup

```typescript
// test-utils.tsx
import { render as rtlRender } from '@testing-library/react'
import { ThemeProvider } from '@/components/theme-provider'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

function render(ui: React.ReactElement, options = {}) {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  })

  return rtlRender(
    <QueryClientProvider client={queryClient}>
      <ThemeProvider>{ui}</ThemeProvider>
    </QueryClientProvider>,
    options
  )
}

export * from '@testing-library/react'
export { render }
```

## Accessibility Testing
- Test keyboard navigation
- Verify ARIA labels and descriptions
- Test focus management
- Use jest-axe for automated accessibility testing

```typescript
import { axe, toHaveNoViolations } from 'jest-axe'

expect.extend(toHaveNoViolations)

it('should not have accessibility violations', async () => {
  const { container } = render(<ComponentName />)
  const results = await axe(container)
  expect(results).toHaveNoViolations()
})
```

## Performance Testing
- Test component rendering performance
- Use React DevTools Profiler in tests
- Test memory leaks with cleanup
- Monitor bundle size impact

## Integration Testing
- Test component interactions
- Test form submissions and validation
- Test routing and navigation
- Test state management flows

## Error Boundary Testing
- Test error scenarios
- Verify error boundaries catch and display errors
- Test error recovery mechanisms

## Snapshot Testing
- Use sparingly and only for stable components
- Update snapshots intentionally
- Review snapshot diffs carefully
- Don't rely solely on snapshots

## Test Coverage
- Aim for high test coverage (80%+)
- Focus on critical user paths
- Test edge cases and error scenarios
- Use coverage reports to identify gaps

## Testing Best Practices
- Keep tests simple and focused
- Use descriptive test names
- Avoid testing implementation details
- Test user behavior, not internal state
- Use proper cleanup in afterEach
- Mock external dependencies consistently
- Test both success and failure scenarios
- Use data attributes only when necessary
- Prefer semantic queries over test IDs
- Test accessibility features

## Common Testing Patterns
- Test component rendering
- Test user interactions
- Test prop changes
- Test event handling
- Test conditional rendering
- Test loading states
- Test error states
- Test form validation
- Test API integration
- Test routing behavior

## Testing Tools and Libraries
- Jest: Test runner and assertion library for unit/integration tests
- React Testing Library: Component testing utilities
- @testing-library/user-event: User interaction simulation
- MSW: API mocking
- jest-axe: Accessibility testing
- @testing-library/jest-dom: Custom matchers
- @testing-library/react-hooks: Hook testing
- Playwright: End-to-end testing framework
- test-utils: Custom testing utilities

## Playwright E2E Testing
- Use Playwright for testing complete user workflows
- Test across multiple browsers (Chromium, Firefox, WebKit)
- Focus on user journeys and critical business paths
- Use page object models for maintainable tests
- Test responsive design and cross-browser compatibility
- Use visual regression testing for UI consistency
- Test accessibility features in real browser environments

### Playwright Test Structure
```typescript
import { test, expect } from '@playwright/test'

test.describe('User Authentication', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/login')
  })

  test('should login successfully with valid credentials', async ({ page }) => {
    // Fill login form
    await page.fill('[data-testid="email"]', 'user@example.com')
    await page.fill('[data-testid="password"]', 'password123')
    
    // Submit form
    await page.click('[data-testid="login-button"]')
    
    // Verify successful login
    await expect(page).toHaveURL('/dashboard')
    await expect(page.locator('[data-testid="user-menu"]')).toBeVisible()
  })

  test('should show error message with invalid credentials', async ({ page }) => {
    await page.fill('[data-testid="email"]', 'invalid@example.com')
    await page.fill('[data-testid="password"]', 'wrongpassword')
    await page.click('[data-testid="login-button"]')
    
    await expect(page.locator('[data-testid="error-message"]')).toBeVisible()
    await expect(page.locator('[data-testid="error-message"]')).toContainText('Invalid credentials')
  })
})
```

### Page Object Model
```typescript
// pages/LoginPage.ts
export class LoginPage {
  constructor(private page: Page) {}

  async goto() {
    await this.page.goto('/login')
  }

  async login(email: string, password: string) {
    await this.page.fill('[data-testid="email"]', email)
    await this.page.fill('[data-testid="password"]', password)
    await this.page.click('[data-testid="login-button"]')
  }

  async getErrorMessage() {
    return this.page.locator('[data-testid="error-message"]')
  }

  async expectToBeOnPage() {
    await expect(this.page).toHaveURL('/login')
  }
}

// tests/login.spec.ts
import { test, expect } from '@playwright/test'
import { LoginPage } from '../pages/LoginPage'

test.describe('Login Page', () => {
  let loginPage: LoginPage

  test.beforeEach(async ({ page }) => {
    loginPage = new LoginPage(page)
    await loginPage.goto()
  })

  test('should display login form', async () => {
    await expect(page.locator('[data-testid="email"]')).toBeVisible()
    await expect(page.locator('[data-testid="password"]')).toBeVisible()
    await expect(page.locator('[data-testid="login-button"]')).toBeVisible()
  })
})
```

### Playwright Configuration
```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test'

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 12'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
})
```

### E2E Testing Best Practices
- Test complete user workflows, not isolated features
- Use realistic test data and scenarios
- Test error handling and edge cases
- Verify accessibility in real browser environments
- Test responsive design across different screen sizes
- Use visual regression testing for UI consistency
- Test performance and loading times
- Mock external services appropriately
- Use test data factories for consistent test data
- Implement proper test isolation and cleanup

### Visual Regression Testing
```typescript
test('should match login page screenshot', async ({ page }) => {
  await page.goto('/login')
  await expect(page).toHaveScreenshot('login-page.png')
})

test('should match form validation states', async ({ page }) => {
  await page.goto('/login')
  
  // Test empty form validation
  await page.click('[data-testid="login-button"]')
  await expect(page).toHaveScreenshot('login-validation-errors.png')
  
  // Test successful form submission
  await page.fill('[data-testid="email"]', 'user@example.com')
  await page.fill('[data-testid="password"]', 'password123')
  await expect(page).toHaveScreenshot('login-form-filled.png')
})
```

## Example Test Suite
```typescript
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import '@testing-library/jest-dom'
import { Button } from './Button'

describe('Button', () => {
  const defaultProps = {
    onClick: jest.fn(),
    children: 'Click me',
  }

  beforeEach(() => {
    jest.clearAllMocks()
  })

  it('should render with correct text', () => {
    render(<Button {...defaultProps} />)
    expect(screen.getByRole('button')).toHaveTextContent('Click me')
  })

  it('should call onClick when clicked', async () => {
    const user = userEvent.setup()
    render(<Button {...defaultProps} />)
    
    const button = screen.getByRole('button')
    await user.click(button)
    
    expect(defaultProps.onClick).toHaveBeenCalledTimes(1)
  })

  it('should be disabled when disabled prop is true', () => {
    render(<Button {...defaultProps} disabled />)
    expect(screen.getByRole('button')).toBeDisabled()
  })

  it('should show loading state when isLoading is true', () => {
    render(<Button {...defaultProps} isLoading />)
    expect(screen.getByRole('button')).toBeDisabled()
    expect(screen.getByText('Loading...')).toBeInTheDocument()
  })
})
```
# Testing Rules for React/Next.js Applications

## Testing Framework Setup
- Use Jest as the primary testing framework for unit and integration tests
- Use React Testing Library (RTL) for component testing
- Use @testing-library/jest-dom for custom matchers
- Use @testing-library/user-event for user interaction testing
- Use MSW (Mock Service Worker) for API mocking
- Use @testing-library/react-hooks for testing custom hooks
- Use Playwright for end-to-end (E2E) testing

## Test File Organization
- Place test files alongside source files with `.test.tsx` or `.spec.tsx` extension
- Use `__tests__` directories for complex test suites
- Group related tests using `describe` blocks
- Use descriptive test names that explain the expected behavior
- Follow the pattern: "should [expected behavior] when [condition]"

## Component Testing Best Practices
- Test component behavior, not implementation details
- Focus on user interactions and outcomes
- Use semantic queries (getByRole, getByLabelText) over getByTestId
- Test accessibility features and keyboard navigation
- Mock external dependencies and API calls
- Test component variants and edge cases
- Use data-testid sparingly and only for elements that can't be queried semantically

## Test Structure
```typescript
import { render, screen, fireEvent } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import '@testing-library/jest-dom'

describe('ComponentName', () => {
  const defaultProps = {
    // Define default props here
  }

  it('should render correctly with default props', () => {
    render(<ComponentName {...defaultProps} />)
    expect(screen.getByRole('button')).toBeInTheDocument()
  })

  it('should handle user interactions correctly', async () => {
    const user = userEvent.setup()
    render(<ComponentName {...defaultProps} />)
    
    const button = screen.getByRole('button')
    await user.click(button)
    
    expect(screen.getByText('Expected text')).toBeInTheDocument()
  })
})
```

## Custom Hook Testing
- Use @testing-library/react-hooks for testing custom hooks
- Test hook behavior in isolation
- Mock external dependencies
- Test error states and edge cases

```typescript
import { renderHook, waitFor } from '@testing-library/react'
import { useCustomHook } from './useCustomHook'

describe('useCustomHook', () => {
  it('should return initial state', () => {
    const { result } = renderHook(() => useCustomHook())
    expect(result.current.data).toBeNull()
    expect(result.current.loading).toBe(true)
  })

  it('should handle async operations', async () => {
    const { result } = renderHook(() => useCustomHook())
    
    await waitFor(() => {
      expect(result.current.loading).toBe(false)
    })
    
    expect(result.current.data).toBeDefined()
  })
})
```

## API Mocking
- Use MSW for API mocking in tests
- Mock API responses for different scenarios
- Test loading states, success states, and error states
- Verify API calls are made with correct parameters

```typescript
import { rest } from 'msw'
import { setupServer } from 'msw/node'

const server = setupServer(
  rest.get('/api/data', (req, res, ctx) => {
    return res(ctx.json({ data: 'test data' }))
  }),
  rest.post('/api/submit', (req, res, ctx) => {
    return res(ctx.json({ success: true }))
  })
)

beforeAll(() => server.listen())
afterEach(() => server.resetHandlers())
afterAll(() => server.close())
```

## Test Utilities and Helpers
- Create custom render functions for components with providers
- Use test-utils for common testing patterns
- Create mock data factories for consistent test data
- Use beforeEach for common setup

```typescript
// test-utils.tsx
import { render as rtlRender } from '@testing-library/react'
import { ThemeProvider } from '@/components/theme-provider'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

function render(ui: React.ReactElement, options = {}) {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  })

  return rtlRender(
    <QueryClientProvider client={queryClient}>
      <ThemeProvider>{ui}</ThemeProvider>
    </QueryClientProvider>,
    options
  )
}

export * from '@testing-library/react'
export { render }
```

## Accessibility Testing
- Test keyboard navigation
- Verify ARIA labels and descriptions
- Test focus management
- Use jest-axe for automated accessibility testing

```typescript
import { axe, toHaveNoViolations } from 'jest-axe'

expect.extend(toHaveNoViolations)

it('should not have accessibility violations', async () => {
  const { container } = render(<ComponentName />)
  const results = await axe(container)
  expect(results).toHaveNoViolations()
})
```

## Performance Testing
- Test component rendering performance
- Use React DevTools Profiler in tests
- Test memory leaks with cleanup
- Monitor bundle size impact

## Integration Testing
- Test component interactions
- Test form submissions and validation
- Test routing and navigation
- Test state management flows

## Error Boundary Testing
- Test error scenarios
- Verify error boundaries catch and display errors
- Test error recovery mechanisms

## Snapshot Testing
- Use sparingly and only for stable components
- Update snapshots intentionally
- Review snapshot diffs carefully
- Don't rely solely on snapshots

## Test Coverage
- Aim for high test coverage (80%+)
- Focus on critical user paths
- Test edge cases and error scenarios
- Use coverage reports to identify gaps

## Testing Best Practices
- Keep tests simple and focused
- Use descriptive test names
- Avoid testing implementation details
- Test user behavior, not internal state
- Use proper cleanup in afterEach
- Mock external dependencies consistently
- Test both success and failure scenarios
- Use data attributes only when necessary
- Prefer semantic queries over test IDs
- Test accessibility features

## Common Testing Patterns
- Test component rendering
- Test user interactions
- Test prop changes
- Test event handling
- Test conditional rendering
- Test loading states
- Test error states
- Test form validation
- Test API integration
- Test routing behavior

## Testing Tools and Libraries
- Jest: Test runner and assertion library for unit/integration tests
- React Testing Library: Component testing utilities
- @testing-library/user-event: User interaction simulation
- MSW: API mocking
- jest-axe: Accessibility testing
- @testing-library/jest-dom: Custom matchers
- @testing-library/react-hooks: Hook testing
- Playwright: End-to-end testing framework
- test-utils: Custom testing utilities

## Playwright E2E Testing
- Use Playwright for testing complete user workflows
- Test across multiple browsers (Chromium, Firefox, WebKit)
- Focus on user journeys and critical business paths
- Use page object models for maintainable tests
- Test responsive design and cross-browser compatibility
- Use visual regression testing for UI consistency
- Test accessibility features in real browser environments

### Playwright Test Structure
```typescript
import { test, expect } from '@playwright/test'

test.describe('User Authentication', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/login')
  })

  test('should login successfully with valid credentials', async ({ page }) => {
    // Fill login form
    await page.fill('[data-testid="email"]', 'user@example.com')
    await page.fill('[data-testid="password"]', 'password123')
    
    // Submit form
    await page.click('[data-testid="login-button"]')
    
    // Verify successful login
    await expect(page).toHaveURL('/dashboard')
    await expect(page.locator('[data-testid="user-menu"]')).toBeVisible()
  })

  test('should show error message with invalid credentials', async ({ page }) => {
    await page.fill('[data-testid="email"]', 'invalid@example.com')
    await page.fill('[data-testid="password"]', 'wrongpassword')
    await page.click('[data-testid="login-button"]')
    
    await expect(page.locator('[data-testid="error-message"]')).toBeVisible()
    await expect(page.locator('[data-testid="error-message"]')).toContainText('Invalid credentials')
  })
})
```

### Page Object Model
```typescript
// pages/LoginPage.ts
export class LoginPage {
  constructor(private page: Page) {}

  async goto() {
    await this.page.goto('/login')
  }

  async login(email: string, password: string) {
    await this.page.fill('[data-testid="email"]', email)
    await this.page.fill('[data-testid="password"]', password)
    await this.page.click('[data-testid="login-button"]')
  }

  async getErrorMessage() {
    return this.page.locator('[data-testid="error-message"]')
  }

  async expectToBeOnPage() {
    await expect(this.page).toHaveURL('/login')
  }
}

// tests/login.spec.ts
import { test, expect } from '@playwright/test'
import { LoginPage } from '../pages/LoginPage'

test.describe('Login Page', () => {
  let loginPage: LoginPage

  test.beforeEach(async ({ page }) => {
    loginPage = new LoginPage(page)
    await loginPage.goto()
  })

  test('should display login form', async () => {
    await expect(page.locator('[data-testid="email"]')).toBeVisible()
    await expect(page.locator('[data-testid="password"]')).toBeVisible()
    await expect(page.locator('[data-testid="login-button"]')).toBeVisible()
  })
})
```

### Playwright Configuration
```typescript
// playwright.config.ts
import { defineConfig, devices } from '@playwright/test'

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure',
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 12'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:3000',
    reuseExistingServer: !process.env.CI,
  },
})
```

### E2E Testing Best Practices
- Test complete user workflows, not isolated features
- Use realistic test data and scenarios
- Test error handling and edge cases
- Verify accessibility in real browser environments
- Test responsive design across different screen sizes
- Use visual regression testing for UI consistency
- Test performance and loading times
- Mock external services appropriately
- Use test data factories for consistent test data
- Implement proper test isolation and cleanup

### Visual Regression Testing
```typescript
test('should match login page screenshot', async ({ page }) => {
  await page.goto('/login')
  await expect(page).toHaveScreenshot('login-page.png')
})

test('should match form validation states', async ({ page }) => {
  await page.goto('/login')
  
  // Test empty form validation
  await page.click('[data-testid="login-button"]')
  await expect(page).toHaveScreenshot('login-validation-errors.png')
  
  // Test successful form submission
  await page.fill('[data-testid="email"]', 'user@example.com')
  await page.fill('[data-testid="password"]', 'password123')
  await expect(page).toHaveScreenshot('login-form-filled.png')
})
```

## Example Test Suite
```typescript
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import userEvent from '@testing-library/user-event'
import '@testing-library/jest-dom'
import { Button } from './Button'

describe('Button', () => {
  const defaultProps = {
    onClick: jest.fn(),
    children: 'Click me',
  }

  beforeEach(() => {
    jest.clearAllMocks()
  })

  it('should render with correct text', () => {
    render(<Button {...defaultProps} />)
    expect(screen.getByRole('button')).toHaveTextContent('Click me')
  })

  it('should call onClick when clicked', async () => {
    const user = userEvent.setup()
    render(<Button {...defaultProps} />)
    
    const button = screen.getByRole('button')
    await user.click(button)
    
    expect(defaultProps.onClick).toHaveBeenCalledTimes(1)
  })

  it('should be disabled when disabled prop is true', () => {
    render(<Button {...defaultProps} disabled />)
    expect(screen.getByRole('button')).toBeDisabled()
  })

  it('should show loading state when isLoading is true', () => {
    render(<Button {...defaultProps} isLoading />)
    expect(screen.getByRole('button')).toBeDisabled()
    expect(screen.getByText('Loading...')).toBeInTheDocument()
  })
})
```
